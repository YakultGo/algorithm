### 基础线段树，单点修改，区间查询（数组实现）

```c++
		int n;
    int sum[4n+1];
    // 初始化线段树   o,l,r=1,1,n
    void build(vector<int> &a, int o, int l, int r) {
        if (l == r) {
            sum[o] = a[l - 1];
            return;
        }
        int m = (l + r) / 2;
        build(a, o * 2, l, m);
        build(a, o * 2 + 1, m + 1, r);
      	sum[o] = sum[2*o] + sum[2*o+1];
    }
    // 将 idx 上的元素值增加 val, o,l,r=1,1,n
    void add(int o, int l, int r, int idx, int val) {
        if (l == r) {
            sum[o] += val;
            return;
        }
        int m = (l + r) / 2;
        if (idx <= m) add(o * 2, l, m, idx, val);
        else add(o * 2 + 1, m + 1, r, idx, val);
        sum[o] = sum[o * 2] + sum[o * 2 + 1];
    }

    // 返回区间 [L,R] 内的元素和, o,l,r=1,1,n
    long query_sum(int o, int l, int r, int L, int R) { // L 和 R 在整个递归过程中均不变，将其大写，视作常量
        if(l > R || r < L) return 0; // 看情况加不加这行
      	if (L <= l && r <= R) return sum[o];
        long sum = 0L;
        int m = (l + r) / 2;
        if (L <= m) sum += query_sum(o * 2, l, m, L, R);
        if (R > m) sum += query_sum(o * 2 + 1, m + 1, r, L, R);
        return sum;
    }
```

### 动态开点线段树（new 普通写法）

当n比较大时，预先分配4n大小的数组不现实

```c++
struct Node{
    int val,lazy;//当前节点值和懒惰标记
    Node *left;
    Node *right;
    Node() : val(0), lazy(0), left(nullptr), right(nullptr) {}
};
constexpr static int N=1e9;
Node* root = new Node();
int query(Node* root, int start, int end, int l, int r) {
    if (l <= start && end <= r) return root->val;
    int ans = 0;
    int mid = start+(end - start)/2;
    pushDown(root, mid - start + 1, end - mid);
    if (l <= mid) ans += query(root->left, start, mid, l, r);
    if (r > mid) ans += query(root->right, mid + 1, end, l, r);
    return ans;
}
void pushDown(Node* root, int leftNum, int rightNum) {
    // 动态开点
    if (root->left == nullptr) root->left = new Node();
    if (root->right == nullptr) root->right = new Node();
    if (root->lazy == 0) return ;
    root->left->val += root->lazy * leftNum;
    root->right->val += root->lazy * rightNum;
    root->left->lazy = root->lazy;
    root->right->lazy = root->lazy;
    root->lazy = 0;
}
void update(Node* root, int start, int end, int l, int r, int val) {
    if (l <= start && end <= r) {
        root->val += (end - start + 1) * val;
        root->lazy += val;
        return ;
    }
    int mid = start+(end - start)/2;
    pushDown(root, mid - start + 1, end - mid);
    if (l <= mid) update(root->left, start, mid, l, r, val);
    if (r > mid) update(root->right, mid + 1, end, l, r, val);
    pushUp(root);
}
void pushUp(Node* root){
    root->val = root->left->val+root->right->val;
}
```

由于c++中的new操作分配在堆区，如果空间不够的时候，会合并内存碎片，这样太耗时间了，有两种解决方法，一种是leetcode大佬hqzture，见[讨论区](https://leetcode.cn/circle/discuss/0vjSA9/%20/)，开头部分是模板，直接复制上去即可

>目的是手动实现一个比系统更快的 new 操作

### 动态开点线段树（new 优化写法）

```c++
template<class T> class CachedObj{
public:
	void *operator new(size_t s){
		if (!head){
			T *a=new T[SIZE];
			for (size_t i=0;i<SIZE;++i)add(a+i);
		}
		T *p=head;head=head->CachedObj<T>::next;return p;
	}
	void operator delete(void *p,size_t){if (p)add(static_cast<T*>(p));}
	virtual ~CachedObj(){}
protected:
	T *next;
private:
	static T *head;static const size_t SIZE;
	static void add(T *p){p->CachedObj<T>::next=head;head=p;}
};
template<class T> T *CachedObj<T>::head=0;
template<class T> const size_t CachedObj<T>::SIZE=10000;
class Node:public CachedObj<Node>{
public:
    int val,lazy;//当前节点值和懒惰标记
    Node *left;
    Node *right;
    Node() : val(0), lazy(0), left(nullptr), right(nullptr) {}
};
constexpr static int N=1e9;
Node* root = new Node();
int query(Node* root, int start, int end, int l, int r) {
    if (l <= start && end <= r) return root->val;
    int ans = 0;
    int mid = start+(end - start)/2;
    pushDown(root, mid - start + 1, end - mid);
    if (l <= mid) ans += query(root->left, start, mid, l, r);
    if (r > mid) ans += query(root->right, mid + 1, end, l, r);
    return ans;
}
void pushDown(Node* root, int leftNum, int rightNum) {
    // 动态开点
    if (root->left == nullptr) root->left = new Node();
    if (root->right == nullptr) root->right = new Node();
    if (root->lazy == 0) return ;
    root->left->val += root->lazy * leftNum;
    root->right->val += root->lazy * rightNum;
    root->left->lazy = root->lazy;
    root->right->lazy = root->lazy;
    root->lazy = 0;
}
void update(Node* root, int start, int end, int l, int r, int val) {
    if (l <= start && end <= r) {
        root->val += (end - start + 1) * val;
        root->lazy += val;
        return ;
    }
    int mid = start+(end - start)/2;
    pushDown(root, mid - start + 1, end - mid);
    if (l <= mid) update(root->left, start, mid, l, r, val);
    if (r > mid) update(root->right, mid + 1, end, l, r, val);
    pushUp(root);
}
void pushUp(Node* root){
    root->val = root->left->val+root->right->val;
}
```

还有一种可以提前申请好一个数组大小为M，如果wa了，可以增加M的值

### 动态开点线段树（数组写法）

```c++
    constexpr static int N = 1e9;
    constexpr static int M = 1e5;//这里就是提前申请的内存数，如果WA了，此处就可以在修改 
    struct node{
    int sum,lazy,left,right;
        node():sum(0),lazy(0),left(0),right(0){}
    }tree[M];
    int index=0;
    void update(int u,int start,int end,int l,int r,int delta){
        if(l<=start && end<=r){
            tree[u].sum+=(end-start+1)*delta;
            tree[u].lazy+=delta;
            return;
        }
        int m=(start+end)>>1;
        lazyCreate(u);
        pushdown(u,start,end);
        if(l<=m) update(tree[u].left,start,m,l,r,delta);
        if(r>m) update(tree[u].right,m+1,end,l,r,delta);
        pushup(u);
    }
    int query(int u,int start,int end,int l,int r){
        if(l<=start && end<=r) return tree[u].sum;
        lazyCreate(u);
        pushdown(u,start,end);
        int m=(start+end)>>1;
        int ans=0;
        if(l<=m) ans+=query(tree[u].left,start,m,l,r);
        if(r>m) ans+=query(tree[u].right,m+1,end,l,r);
        return ans;
    }
    void lazyCreate(int u){
        if(!tree[u].left)tree[u].left=++index;
        if(!tree[u].right)tree[u].right=++index;
    }
    void pushdown(int u,int start,int end){
        int delta=tree[u].lazy;
        if(delta == 0) return;
        int m=(start+end)>>1;
        tree[tree[u].left].lazy+=delta;
        tree[tree[u].right].lazy+=delta;
        tree[tree[u].left].sum+=(m-start+1)*delta;
        tree[tree[u].right].sum+=(end-m)*delta;
        tree[u].lazy=0;
    }
    void pushup(int u){
        tree[u].sum=tree[tree[u].left].sum+tree[tree[u].right].sum;
    }
```

