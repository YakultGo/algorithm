[leetcode 1135.最低成本联通所有城市](https://leetcode.cn/problems/connecting-cities-with-minimum-cost/description/)

# 普通并查集

```c++
class Solution {
public:
    struct dsu {
        vector<int> pa, size;
        explicit dsu(int size_) : pa(size_), size(size_, 1) {
            iota(pa.begin(), pa.end(), 0);
        }
        void unite(int x, int y) {
            x = find(x), y = find(y);
            if (x == y) return;
            if (size[x] < size[y]) 
                swap(x, y);
            pa[y] = x;
            size[x] += size[y];
        }
        int find(int x) {
            return pa[x] == x ? x : pa[x] = find(pa[x]);
        }
    };

    int minimumCost(int n, vector<vector<int>>& connections) {
        // 最小生成树，两个算法Kruskal和Prim
        sort(connections.begin(),connections.end(),[&](const auto&a, const auto&b){
            return a[2] < b[2];
        });
        int ans = 0;
        dsu d(n+1);
        for(auto &c : connections) {
            int x = c[0], y = c[1];
            if(d.find(x) != d.find(y)) {
                ans += c[2];
                d.unite(x,y);
                n--;
            }
        }
        // 连通n个点，需要n-1条边
        return n == 1 ? ans : -1;
    }
};
```

> 连通分量并查集

```c++
struct dsu {
        vector<int> pa, size;
        int count;
        explicit dsu(int size_) : pa(size_), size(size_, 1),count(0) {
            iota(pa.begin(), pa.end(), 0);
        }
        void unite(int x, int y) {
            x = find(x), y = find(y);
            if (x == y) return;
            if (size[x] < size[y]) 
                swap(x, y);
            pa[y] = x;
            size[x] += size[y];
            count--;
        }
        int find(int x) {
            return pa[x] == x ? x : pa[x] = find(pa[x]);
        }
        void addCount(){
            count++;
        }
        int getCount(){
            return count;
        }
        bool isConnected(int x, int y) {
            return find(x) == find(y);
        }
    };
```

