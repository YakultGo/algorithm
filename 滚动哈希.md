字符串单哈希

```c++
using LL = long long;
int mod = (int)1e9 + 7, base = 31;
int n;
vector<int> pre(n + 1, 0), mul(n + 1, 1);
for (int i = 1; i <= n; ++i) {
    pre[i] = ((LL)pre[i - 1] * base + text[i - 1]) % mod;
    mul[i] = (LL)mul[i - 1] * base % mod;
}
auto gethash = [&] (int l, int r) {
    return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;
};
```

字符串双哈希

```c++
using LL = long long;
int mod1 = 1e9 + 7, base1 = 31;
int mod2 = 998244353, base2 = 131;
int n;
vector<int> pre1(n + 1, 0), mul1(n + 1, 1);
vector<int> pre2(n + 1, 0), mul2(n + 1, 1);
for (int i = 1; i <= n; ++i) {
    pre1[i] = ((LL)pre1[i - 1] * base1 + text[i - 1]) % mod1;
    pre2[i] = ((LL)pre2[i - 1] * base2 + text[i - 1]) % mod2;
    mul1[i] = (LL)mul1[i - 1] * base1 % mod1;
    mul2[i] = (LL)mul2[i - 1] * base2 % mod2;
}
auto gethash = [&](int l, int r) -> pair<int,int> {
    int h1 = (pre1[r + 1] - (LL)pre1[l] * mul1[r - l + 1] % mod1 + mod1) % mod1;
    int h2 = (pre2[r + 1] - (LL)pre2[l] * mul2[r - l + 1] % mod2 + mod2) % mod2;
    return {h1,h2};
};
```

也可以使用随机数

```c++
srand(time(0));
using LL = long long;
int mod = 998244353 + rand() % 10000, base = 27 + rand() % 10;
int n;
vector<int> pre(n + 1, 0), mul(n + 1, 1);
for (int i = 1; i <= n; ++i) {
    pre[i] = ((LL)pre[i - 1] * base + text[i - 1]) % mod;
    mul[i] = (LL)mul[i - 1] * base % mod;
}
auto gethash = [&] (int l, int r) {
    return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;
};
```

逆着字符串哈希

```c++
using LL = long long;
int n = s.size();
int mod = (int)1e9 + 7, base = 31;
vector<int> pre(n + 1, 0), mul(n + 1, 1);
for (int i = 1; i <= n; ++i) {
    pre[i] = ((LL)pre[i - 1] * base + s[i - 1]) % mod;
    mul[i] = (LL)mul[i - 1] * base % mod;
}
vector<int> pre_rev(n + 1, 0);
for(int i = n-1; i >= 0; i--) {
    pre_rev[i] = ((LL)pre_rev[i + 1] * base + s[i]) % mod;
}
auto gethash1 = [&] (int l, int r) {
    return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;
};
auto gethash2 = [&] (int l, int r) {
    return (pre_rev[l] - (LL)pre_rev[r + 1] * mul[r - l + 1] % mod + mod) % mod;
};
```

KMP

```c++
vector<int> kmp(string &text, string &pattern) {
    int m = pattern.length();
    vector<int> pi(m);
    int c = 0;
    for (int i = 1; i < m; i++) {
        char v = pattern[i];
        while (c && pattern[c] != v) {
            c = pi[c - 1];
        }
        if (pattern[c] == v) {
            c++;
        }
        pi[i] = c;
    }
    vector<int> res;
    c = 0;
    for (int i = 0; i < text.length(); i++) {
        char v = text[i];
        while (c && pattern[c] != v) {
            c = pi[c - 1];
        }
        if (pattern[c] == v) {
            c++;
        }
        if (c == m) {
            res.push_back(i - m + 1);
            c = pi[c - 1];
        }
    }
    return res;
}
```

